"""Backtest engine core - processes historical candle data."""

import pandas as pd
import numpy as np
from pathlib import Path
from typing import Dict, Any, List, Optional
import pytz
from datetime import datetime

from .indicators import compute_rsi
from .session_clock import SessionClock


class BacktestEngine:
    """Core backtesting engine for RSI-2 strategy."""

    def __init__(self, config: Dict[str, Any]):
        """
        Initialize backtest engine.

        Args:
            config: Configuration dictionary
        """
        self.config = config
        self.session_clock = SessionClock(config)
        self.rsi_period = config.get('rsi_period', 2)
        self.spread_pts = config.get('spread_assumption_pts', 0.6)
        self.size_gbp_per_point = config.get('size_gbp_per_point', 1.0)

        # Strategy mode: "long", "short", or "both"
        self.strategy_mode = config.get('strategy_mode', 'long')

        # LONG strategy settings (with fallback to legacy config)
        long_config = config.get('long', {})
        self.long_oversold = long_config.get('oversold_threshold', config.get('oversold', 5.0))
        self.long_tp = long_config.get('tp_pts', config.get('take_profits_pts', 40))
        self.long_sl = long_config.get('sl_pts', config.get('stop_loss_pts', 100))
        self.long_use_trailing = long_config.get('use_trailing_stop', config.get('use_trailing_stop', True))
        self.long_trailing_activation = long_config.get('trailing_activation_pts', config.get('trailing_stop_activation_pts', 25))
        self.long_trailing_distance = long_config.get('trailing_distance_pts', config.get('trailing_stop_distance_pts', 10))
        self.long_force_eod = long_config.get('force_eod_exit', config.get('force_eod_exit', True))
        self.long_max_hold_days = long_config.get('max_hold_days', config.get('max_hold_days', 0))

        # SHORT strategy settings
        short_config = config.get('short', {})
        self.short_overbought = short_config.get('overbought_threshold', 96.0)
        self.short_tp = short_config.get('tp_pts', 40)
        self.short_sl = short_config.get('sl_pts', 80)
        self.short_use_trailing = short_config.get('use_trailing_stop', True)
        self.short_trailing_activation = short_config.get('trailing_activation_pts', 25)
        self.short_trailing_distance = short_config.get('trailing_distance_pts', 10)
        self.short_force_eod = short_config.get('force_eod_exit', False)
        self.short_max_hold_days = short_config.get('max_hold_days', 0)

        # Legacy settings (keep for backward compatibility with old code)
        self.oversold = self.long_oversold
        self.stop_loss_pts = self.long_sl
        self.use_trailing_stop = self.long_use_trailing
        self.trailing_stop_distance = self.long_trailing_distance
        self.trailing_stop_activation = self.long_trailing_activation
        self.force_eod_exit = self.long_force_eod
        self.max_hold_days = self.long_max_hold_days

        # Overnight funding configuration
        self.overnight_funding_rate = config.get('overnight_funding_rate_pct', 0.035)
        self.off_hours_spread_mult = config.get('off_hours_spread_multiplier', 2.5)

        # Margin validator
        from .margin_validator import MarginValidator
        self.margin_validator = MarginValidator(config)

        # Stats tracking
        self.trades_blocked_margin = 0

    def load_data(self, data_path: str) -> pd.DataFrame:
        """
        Load CSV data from file or directory.

        Args:
            data_path: Path to CSV file or directory containing CSVs

        Returns:
            DataFrame with columns: timestamp, open, high, low, close, volume
        """
        path = Path(data_path)
        dfs = []

        if path.is_file():
            df = pd.read_csv(path)
            dfs.append(df)
        elif path.is_dir():
            csv_files = sorted(path.glob('*.csv'))
            for csv_file in csv_files:
                # Skip tick data files (they contain 'full' in filename)
                if 'full' in csv_file.name.lower() or 'tick' in csv_file.name.lower():
                    continue
                df = pd.read_csv(csv_file)
                dfs.append(df)
        else:
            raise ValueError(f"Invalid data path: {data_path}")

        if not dfs:
            raise ValueError(f"No CSV files found in {data_path}")

        # Concatenate all dataframes
        df = pd.concat(dfs, ignore_index=True)

        # Normalize column names to lowercase
        df.columns = df.columns.str.lower()

        # Map common column name variations
        column_mapping = {
            'datetime': 'timestamp',
            'date': 'timestamp',
            'time': 'timestamp'
        }
        df.rename(columns=column_mapping, inplace=True)

        # Ensure required columns exist (volume is optional)
        required_cols = ['timestamp', 'open', 'high', 'low', 'close']
        missing = [col for col in required_cols if col not in df.columns]
        if missing:
            raise ValueError(f"Missing required columns: {missing}")

        # Add volume column if missing (set to 0)
        if 'volume' not in df.columns:
            df['volume'] = 0

        # Parse timestamps
        df['timestamp'] = pd.to_datetime(df['timestamp'])

        # Sort by timestamp
        df = df.sort_values('timestamp').reset_index(drop=True)

        return df

    def filter_session_bars(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Filter dataframe to only include bars within session hours.

        Args:
            df: Input dataframe with timestamp column

        Returns:
            Filtered dataframe with session bars only
        """
        df = df.copy()

        # Localize timestamps
        df['timestamp_local'] = df['timestamp'].apply(self.session_clock.localize_timestamp)

        # Filter to session hours
        df['in_session'] = df['timestamp'].apply(self.session_clock.is_session_open)
        df = df[df['in_session']].copy()

        # Add entry allowed flag
        df['entry_allowed'] = df['timestamp'].apply(self.session_clock.is_entry_allowed)

        return df.reset_index(drop=True)

    def _calculate_overnight_charge(self, entry_price: float, days_held: int) -> float:
        """
        Calculate overnight funding charge.

        Formula: (Price × Annual_Rate × Days) / 365

        Args:
            entry_price: Position entry price
            days_held: Number of nights held

        Returns:
            Funding charge in points
        """
        if days_held == 0:
            return 0.0

        daily_rate = self.overnight_funding_rate / 365.0
        charge_pts = entry_price * daily_rate * days_held
        return charge_pts

    def _get_spread_for_time(self, timestamp: datetime) -> float:
        """
        Get spread based on time (market hours vs off-hours).

        Args:
            timestamp: Bar timestamp

        Returns:
            Spread in points
        """
        if self.session_clock.is_session_open(timestamp):
            return self.spread_pts  # Normal market hours spread
        else:
            return self.spread_pts * self.off_hours_spread_mult  # Wider off-hours spread

    def run_backtest(self, df: pd.DataFrame, tp_pts: float) -> List[Dict[str, Any]]:
        """
        Run backtest on historical data with REALISTIC modeling.

        Key realistic assumptions:
        1. NO LOOK-AHEAD BIAS: Entry at NEXT bar's open (after RSI signal on current bar close)
        2. PROPER SPREAD: Entry at ask (mid + spread/2), exits at bid (mid - spread/2)
        3. TP/SL checks against bid prices: high - spread/2 for TP, low - spread/2 for SL

        Args:
            df: DataFrame with OHLCV data
            tp_pts: Take profit in points

        Returns:
            List of trade dictionaries
        """
        # Filter to session bars
        df = self.filter_session_bars(df)

        if len(df) == 0:
            return []

        # Compute RSI on close prices
        rsi = compute_rsi(df['close'], self.rsi_period)
        df['rsi'] = rsi

        # Initialize state
        seen_oversold = False
        position = None
        trades = []
        current_date = None
        entry_signal = False  # Signal to enter on NEXT bar

        for idx, row in df.iterrows():
            bar_timestamp = row['timestamp']
            bar_date = self.session_clock.get_trading_date(bar_timestamp)

            # Reset state at start of new trading day
            if current_date is None or bar_date != current_date:
                current_date = bar_date
                if position is None:
                    seen_oversold = False
                    entry_signal = False

            # Skip if RSI not available
            if pd.isna(row['rsi']):
                continue

            # === ENTRY LOGIC ===
            # Check for oversold condition (RSI <= threshold)
            if row['rsi'] <= self.oversold:
                seen_oversold = True

            # Detect entry signal: RSI crosses above threshold after being oversold
            # Signal is generated at bar CLOSE (when RSI is calculated)
            if (position is None and
                not entry_signal and
                seen_oversold and
                row['rsi'] > self.oversold and
                row['entry_allowed']):

                # Mark entry signal for NEXT bar
                entry_signal = True
                seen_oversold = False  # Reset after signal

            # Execute entry on NEXT bar (realistic: no look-ahead)
            elif entry_signal and position is None:
                # Enter at NEXT bar's open + half spread (ask price)
                # This is realistic: signal generated at previous bar close, enter at this bar open
                entry_price = row['open'] + (self.spread_pts / 2)

                position = {
                    'entry_price': entry_price,
                    'entry_time': bar_timestamp,
                    'entry_time_local': self.session_clock.localize_timestamp(bar_timestamp),
                    'entry_date': self.session_clock.localize_timestamp(bar_timestamp).date(),  # For overnight tracking
                    'tp_pts': tp_pts,
                    'sl_pts': self.stop_loss_pts,
                    'bars_held': 0,
                    'days_held': 0,  # Track days for overnight charges
                    'overnight_charges_pts': 0.0,  # Accumulated overnight funding charges
                    'highest_bid': entry_price,  # Track highest price for trailing stop
                    'trailing_stop_active': False,  # Trailing stop activation flag
                    'trailing_sl_level': entry_price - self.stop_loss_pts  # Initialize with fixed SL
                }

                entry_signal = False  # Reset signal

            # === EXIT LOGIC ===
            if position is not None:
                position['bars_held'] += 1

                # Track overnight holds and charges
                current_date = self.session_clock.localize_timestamp(bar_timestamp).date()
                if current_date != position['entry_date']:
                    # Day changed - calculate days held
                    days_diff = (current_date - position['entry_date']).days
                    if days_diff > position['days_held']:
                        # New overnight period - calculate charges
                        nights_to_charge = days_diff - position['days_held']
                        charge = self._calculate_overnight_charge(position['entry_price'], nights_to_charge)
                        position['overnight_charges_pts'] += charge
                        position['days_held'] = days_diff

                # Initialize exit variables
                exit_price = None
                exit_reason = None

                # Check max hold days limit (if set)
                if self.max_hold_days > 0 and position['days_held'] >= self.max_hold_days:
                    # Force exit due to max hold period
                    exit_price = row['close'] - (self.spread_pts / 2)
                    exit_reason = 'MAX_HOLD_DAYS'

                # Get current spread (may be wider during off-hours)
                current_spread = self._get_spread_for_time(bar_timestamp)

                # Get bid prices from bar high/low (mid - spread/2)
                # Use current spread instead of fixed spread
                bid_high = row['high'] - (current_spread / 2)
                bid_low = row['low'] - (current_spread / 2)

                # Calculate TP level (fixed)
                tp_level = position['entry_price'] + tp_pts

                # Update highest bid reached (for trailing stop)
                if bid_high > position['highest_bid']:
                    position['highest_bid'] = bid_high

                # Trailing stop logic (only if enabled in config)
                if self.use_trailing_stop:
                    # Calculate profit so far
                    current_profit = position['highest_bid'] - position['entry_price']

                    # Activate trailing stop if profit threshold reached
                    if not position['trailing_stop_active'] and current_profit >= self.trailing_stop_activation:
                        position['trailing_stop_active'] = True

                    # Update trailing SL if active
                    if position['trailing_stop_active']:
                        # Trailing SL = highest_bid - trailing_distance
                        new_trailing_sl = position['highest_bid'] - self.trailing_stop_distance
                        # Only move SL up, never down
                        if new_trailing_sl > position['trailing_sl_level']:
                            position['trailing_sl_level'] = new_trailing_sl
                else:
                    # Fixed SL (original behavior)
                    position['trailing_sl_level'] = position['entry_price'] - self.stop_loss_pts

                # Current SL level (trailing or fixed)
                sl_level = position['trailing_sl_level']

                # Check SL first (conservative: SL before TP if both hit same bar)
                # SL hit if bid_low <= sl_level
                if bid_low <= sl_level:
                    exit_price = sl_level
                    exit_reason = 'TRAILING_SL' if (self.use_trailing_stop and position['trailing_stop_active']) else 'SL'
                # Then check TP: TP hit if bid_high >= tp_level
                elif bid_high >= tp_level:
                    exit_price = tp_level
                    exit_reason = 'TP'

                # Check for EOD exit (respects force_eod_exit flag)
                if exit_price is None and self.force_eod_exit:
                    is_eod = self.session_clock.is_eod_bar(bar_timestamp, bar_duration_minutes=30)
                    if is_eod:
                        # Exit at close - half spread (bid price)
                        # Use current spread (may be wider at EOD)
                        exit_price = row['close'] - (current_spread / 2)
                        exit_reason = 'EOD'

                # Close position if exit triggered
                if exit_price is not None:
                    # Calculate P&L before overnight charges
                    pnl_pts_gross = exit_price - position['entry_price']

                    # Subtract overnight charges from P&L
                    overnight_charges = position['overnight_charges_pts']
                    pnl_pts_net = pnl_pts_gross - overnight_charges
                    pnl_gbp = pnl_pts_net * self.size_gbp_per_point

                    trade = {
                        'datetime_open': position['entry_time'],
                        'ny_time_open': position['entry_time_local'].strftime('%Y-%m-%d %H:%M:%S'),
                        'entry_price': position['entry_price'],
                        'tp_pts': position['tp_pts'],
                        'sl_pts': position['sl_pts'],
                        'datetime_close': bar_timestamp,
                        'ny_time_close': self.session_clock.localize_timestamp(bar_timestamp).strftime('%Y-%m-%d %H:%M:%S'),
                        'exit_price': exit_price,
                        'exit_reason': exit_reason,
                        'pnl_pts': pnl_pts_net,  # Net P&L after overnight charges
                        'pnl_pts_gross': pnl_pts_gross,  # Gross P&L before charges
                        'overnight_charges': overnight_charges,  # Overnight funding charges
                        'days_held': position['days_held'],  # Days position was held
                        'pnl_gbp': pnl_gbp,
                        'bars_held': position['bars_held']
                    }

                    trades.append(trade)
                    position = None

        return trades
